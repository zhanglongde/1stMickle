性能是一个工程问题
性能因收益而优化

多因素
1.打包（cdst按需）跟开发相关
    webpack是模块化解决方案，主要提高开发效率，再而性能优化
    主要解决：SPA的首屏渲染（前端二次渲染）
    commonChunk webpack4拆分为
    DCE
    tree-shaking
    scope hoisting
    组件引用 按需组件
    按需加载 分块懒加载
    APP Shell
2.宏观 80%（选架务网存）跟架构相关
    技术选型:vue还是react SASS还是LESS 状态管理的选型：vuex?
         主要围绕周边技术、第三方库：比如lodash jQuery
    架构分层:
         SSR:SSR是SPA首屏渲染的终极目的地
         node中间层 直出渲染
         目录结构 模块化
         缓存分层 PWA
         store分层：modules与namespace
    业务流程:首图连缓域按防+预懒加dicph 3个重点业务场景：列表/图片/（数据）缓存
         按需加载/懒执行/懒渲染 长列表/分列表/无限滚动 列表数据的内存缓存/常用数据记忆
         文件策略 图片策略
         图标策略，减少HTTP请求
         提供复用性：组件库
    资源加载
        网络：API层面 域名收敛发散与网络环境 http2 CDN DNS
        缓存：http缓存 数据缓存
          用户层 代理层 Web层 应用层 数据层
        动静分离：资源服务器和应用服务器，甚至组件分离 网站静态化，资源服务器集群
                 CDN
                 不是组件分离得越多越好：域名收敛和发散，弱网环境收敛，PC端可以适当分离
3.微观 20% 跟开发相关
    利用浏览器优化技术 预解析等 域名发散与收敛
    图字优口缩资源 serverPush webp图片
    CDN DNS
    语义空址少元素
    优选避表除多余 珍惜的新强
    流DOM加访UI字正 循环条件与递归 访修事委重排绘 正则避免回溯
    数据访问：管理作用域（缩短作用域链）、 对象成员：原型链（共享一份内存）、缓存对象成员
    DOM访问与修改:批量 documentfragment
    重排重绘：最小化重排重绘 缓存布局信息（减少布局信息的获取次数，用局部变量缓存和操作） 元素脱离动画流 硬件加速
    设计模式 数据结构与算法 内存管理

实际过程中
1.二八原则
2.性能优化靠经验实践
  抓住：性能指标：白首可操下、性能数据跟踪
  多进行：A/B Test
3.有时候顾此失彼
4.优化手段很多，但优化的对象只有：业务和静态资源