性能是一个工程问题
性能因收益而优化

多因素 抓手：关键性能优化点
1.打包（cdst按需）跟开发相关
    webpack是模块化解决方案，主要提高开发效率，再而性能优化
    主要解决：SPA的首屏渲染（前端二次渲染）
    commonChunk webpack4拆分为
        代码分离:分块打包
    DCE
    tree-shaking
    scope hoisting
    组件按需引用
    分块按需加载 动态组件:is render
    APP Shell/骨架屏幕
2.宏观 80%（架务选资源）跟架构相关
    技术选型:vue还是react SASS还是LESS 状态管理的选型：vuex?
         主要围绕周边技术、第三方库：比如lodash jQuery，还是手写
    架构分层:
         SSR:SSR是SPA首屏渲染的终极目的地
         BFF:node中间层 直出渲染
         目录结构 模块化
         缓存分层 PWA
         store分层：modules与namespace
    业务流程:首图连缓域按防+预懒加dicph 3个重点业务场景：列表/图片/（数据）缓存
         按需加载/懒执行/懒渲染 长列表/分列表/无限滚动 列表数据的内存缓存/常用数据记忆
         文件策略 图片策略:减分降地，大中小
         图标策略，减少HTTP请求
         提高复用性：组件库
    资源加载 网缓动静优先级 渐进懒加载
        网络：API层面 域名收敛发散与网络环境 http2 CDN DNS
        缓存：http缓存 数据缓存
          用户层 代理层 Web层 应用层 数据层
        动静分离：资源服务器和应用服务器，甚至组件分离 网站静态化，资源服务器集群
                 CDN 长尾视频
                 不是组件分离得越多越好：域名收敛和发散，弱网环境收敛，PC端可以适当分离
        合理安排优先级:分成三组，基本核心功能（老浏览器也能浏览的核心内容）、增强体验效果（为现代浏览器设计的强大功能和丰富体验）、附加功能（不一定需要并且可以惰性加载的资源，比如字体、轮播脚本、视频播放器、分享按钮等）
        使用微优化和渐进式启动：利用服务端渲染，在页面里面输出一些最小功能JavaScript来保持交互时间接近首次有效绘制时间
        【可操作时间，表示DOM已经解析完成，资源还未下载完】
        使用骨架屏幕，而不是"加载中"动画
        渐进式加载
        懒加载 懒执行 懒渲染
3.微观 20% 跟开发相关  减小首屏体积
    利用浏览器优化技术 预解析等 域名发散与收敛
    图字优口缩资源 serverPush webp图片
    CDN DNS
    语义空址少元素
    优选避表除多余 珍惜的新强
    流DOM加访UI字正 循环条件与递归 访修事委重排绘 正则避免回溯
    数据访问：管理作用域（缩短作用域链）、 对象成员：原型链（共享一份内存）、缓存对象成员
    DOM访问与修改:批量 documentfragment
    重排重绘：【最缓硬脱】最小化重排重绘 缓存布局信息（减少布局信息的获取次数，用局部变量缓存和操作） 元素脱离动画流 硬件加速
    设计模式 数据结构与算法 内存管理

实际过程中
1.二八原则
2.性能优化靠经验实践
  抓住：性能指标：白首可操下、性能数据跟踪
       可操作时间DOMContentLoaded>下载时间loaded
  多进行：A/B Test
3.有时候顾此失彼
4.优化手段很多，但优化的对象只有：业务和静态资源


https://juejin.im/post/5ac1d117f265da2396128b9f?utm_source=gold_browser_extension
https://www.smashingmagazine.com/2018/01/front-end-performance-checklist-2018-pdf-pages/