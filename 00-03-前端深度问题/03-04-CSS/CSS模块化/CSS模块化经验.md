## 1.重置问题 ##
用normalize.css之后，需不要reset?
哪些不需要重置,比如ol li
webkit特有的前缀样式，例如滚动，尤其是手机端


## 2.全局控制与变量 ##
### 2.1全局变量 ###
主色 辅助色 灰阶
品牌色
字体排布
    rem布局需要在Html元素上定制层次感的font-size
    字体 字重（还是定义不同字重的字体）
    字体大小和行高以及两者的逻辑关系
    实际操作的时候，设计稿的字体通常不会这么量化，尤其是sketch可以直接复制粘贴
层叠问题
  z-index全局统一控制
  利用父类的z-index：auto形成夹心饼干的控制技巧
组件共有样式:边框 圆角 阴影
            注意定义一组具有梯度的原子类
### 2.2局部变量 ###
适用于组件内部，尤其嵌套关系复杂的组件样式


### 3.mixin与function ###
除了变量、嵌套之外，mixin就是预编译的另一大杀器

scss的function甚至要定义在变量之前
可以利用scss的@extend使用定义过的类,以及扩展伪元素等
利用scss的数据结构可以最大程度语义化，比如theme-color


## 4.类层次 ##
### 4.1嵌套 ###
用-分割，最好不超过四层
hd bd ft等简单类可以配合父容器类+>使用（还是:【父类-hd】,我觉得预编译直接嵌套可以使用>,而如果需要脱离父类，重新组织意群则使用后者）
hd bd ft 等过于简单的位置类，不适合组件开发，因为存在无法预知的属性没有被书写，而这些属性很容易因为类名重复被全局定义
>hd便于看清层次关系
父类为开关类或者wrapper等，需要使用：【父类-hd】，有利于解耦
决定因素：解耦？层次关系

#### li上是否需要加上xxx-item？ ####
ul上有样式，li上可以减少书写class(ul与li具有极强的相关性),
容器类+后代选择器+xxx-item类：如果非直接关系的容器对li进行限定可以在li上加上类型，以防止嵌套影响，比如.pagination-bar .toolbar-item
                            对于部件灵活性要求较高，在部件上加上类型，便于移植以及改变嵌套关系
总之，部件加类名有利于解耦合防止嵌套影响（需要个部件都加上类），不加类名有利于容器对部件的整体控制
### 4.2并列【Lobotomized owl selector】 ###
两元素之间的间距用选择器+，有利于后续扩展
并列元素可以使用.item+.item控制缝隙样式
### 4.3响应式换行还是定制换行 ###
要不要分为up+down,还是利用浮动+宽度限定挤压到下一行？
如果存在上下行的分割线，则需要添加up+down

弹性盒多行布局的技巧
内部定义宽度，控制单行子元素个数
外一层嵌套一层
### 4.4换行还是不换行，以及溢出处理 ###
文字元素都需要考虑，尤其是填充后台数据的元素，比如列表中的单行
处理方式:文字自适应，但是同时给定max-width

overflow:visible可以充分利用等间距布局的间距
pop out of overflow hidden,即溢出隐藏，但同时需要溢出菜单等
注意：父元素overflow:hidden,子元素100%但溢出
4.5高度全屏自适应
需要自上而下的100%，尤其是html,body，以及Vue的#app


### 5.开关类 ###
开关类分为2种:1.并且关系的开关类，比如active;2.嵌套关系的开关类
### 5.1并且关系的开关类 ###
应该置于最上层，避免下面的子类分别书写
即使没有公共父类，也不应该将开关类置于各个类（甚至各个文件中），应该将相关意群的类写到一组
这一点可能与组件的状态冲突，具体使用需要看哪一种场景结合更紧密
### 5.2嵌套关系的开关类 ###
如果想嵌套一个menu，要不要用一个wrapper包裹了？
   分情况：
   1）样式需要不影响的时候，用wrapper包裹，以防止hover到menu同时等同于hover上
   2）为了避免使用relatedTarget,不用wrapper包裹
不同组件的样式冲突可以用专门的类处理配合选择器+等处理冲突，例如下拉框出现时，屏蔽tooltip，以避免被tooltip遮挡


### 6.组件样式 ###
### 6.1自定义组件 ###
组件样式可以拆分为：基本样式类+尺寸类+风格类，显示隐藏等属性可以由具体使用场景场景确定
大小、风格样式也可以拆分为原子类
按钮组件样式
字体行高确定，padding确定，宽高不固定：随文字变换而宽度不同，不同按钮宽度不同
字体行高确定，上下padding确定，左右padding为0，宽度固定，且文字居中：按钮等宽

组件样式不要包含浮动定位，定制的样式可以由具体的意群控制（特别是使用预编译的嵌套，需要最大程度解耦）
显示隐藏属性也不能包含在组件样式内，应该有其父元素、兄弟元素等控制

组件样式的最外层定位值是否需要限定？
1).允许设定四个方向值
    绝对定位不能限定top,left，否则加上bottom,right变成拉伸了
    或者top:auto;bottom:xxx;
2).只允许设定top left/right bottom
  可以直接限定

大致为：可继承样式，可以跟组件强相关
       不可继承样式，如定位，需要由场景再确定
       这一点也跟CSS Tomb处理具有相似性

### 6.2第三方组件样式 ###
应该自定义一个类名，以别于第三方的内部类名，从而最大程度解耦
覆盖第三方组件样式的时候，使用自定义的组件类名
这样，如果更换一个组件，就能轻松解耦合


### 7.抽象程度 ###
抽象成都从低到高：
原子类
mixin 通用样式库
组件类
代码片段，例如媒体查询

命名难度也逐渐增加


## 8.注释与换行 ##
  /**/ 大意群
  //  小意群
  换行层次：无空行无注释，无空行小意群，单行，双行，4行


## 9.文件结构 ##
### 一般样式结构 ###
### 组件库的样式结构 ###


## 10.常见布局及布局模式 ##


## 11.糟点 ##
### 11.1原子类组件类嵌套的恶性循环 ###
   不将原子类组件类抽离出来，嵌套在业务类下，
   如果业务复杂，再次使用该原子类和组件类的时候，CSS权重必须超过嵌套的CSS权重，做法就是嵌套更深或者加!important
   如此恶性循环，最终CSS难以修改
   解决：抽离原子类组件类，使得权重最低
### 11.2后代宽泛标签的嵌套影响 ###
   容器组件上使用后代选择器限定标签，比如xx-box li
   影响深远，导致子组件必须采用覆盖的方式，以使得权重超过限定的标签权重
   解决：谨慎使用，或者使用子选择>器替代
        或者使用类名限定，比如.pagination-bar .xxx-item
### 11.3定位组件限定top left导致的灵活性降低 ###
   添加bottom right时，必须重置top left
### 11.4复制粘贴设计稿的样式 ###
   设计稿样式冗余度偏高
   可以复制阴影值等